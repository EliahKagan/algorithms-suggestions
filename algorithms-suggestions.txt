Define and write tests for (warmup):
    a function that prints a vector, of anything printable, on a line.
    a function that sorts a vector of int (can use std::sort).
    a function that sorts a vector of int, but puts all odds before all evens.
    a function that finds the index of an element in a vector if present.

Define and write tests for (object pool):
    a class template providing an expanding (but not contracting) object pool.

Define and write tests for (singly linked lists - creation and traversal):
    a singly linked list node type.
    a function that constructs a singly linked list from a vector.
    a function that determines the size of a singly linked list.
    a function that constructs a vector from a singly linked list.
    a function that finds a value, if present, in a singly linked list.
    a function that splits a list into two lists based on matching a predicate.

Define and write tests for (singly linked lists - other common operations):
    a function that compares singly linked lists for sequence equality.
    a function that copies a singly linked list.
    a function that reverses a singly linked list by rearranging its nodes.
    a function that merges two sorted linked lists in sorted order.

Define and write tests for (singly linked lists - topology and cycle detection):
    a function that checks if a singly linked list has a cycle.
    a function that checks if two singly linked lists share any nodes.

Define and write tests for (binary trees - creation and traversal):
    a binary tree node type (without parent pointers).
    a helper function object to make trees like f(4, f(3, {}, {}), f(5, {}, {})).
    a function that determines the size of a binary tree.
    a function that constructs a vector from a binary tree, in any order.
    a function that finds a value's node, if present, in a binary tree.
    preorder, inorder, postorder, and level order traversal, to print values.
    iterative preorder traversal.

Define and write tests for (binary trees - other common operations):
    a function to check if trees' topology and corresponding data are the same.
    a function to copy a tree.
    a function to check if a tree is mirror-symmetric.
    a function to turn a tree into its mirror image by rearranging its nodes.

Define and write tests for (binary trees - topology and cycle detection):
    a function that detects violations of the tree's topological invariant.
    a function that detects only violations that prevent normal traversals.

Write functions/types to (undirected graphs - representation and connectivity):
    given (undirected, unweighted) edges, build an adjacency list.
    given edges, report if there is a (undirected) cycle.
    given edges and {u, v} queries, report if vertices u and v are connected.
    given edges, report the number and size of components.
    use BFS, DFS, and union-find methods for those tasks (if not already done).
